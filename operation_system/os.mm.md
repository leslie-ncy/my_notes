# 操作系统
## 进程

### 基础知识
1. 进程是对运⾏时程序的封装，操作系统进⾏资源调度和分配的基本单位
2. 进程表
   - 为了实现进程模型，操作系统维护着⼀张表格(⼀个结构数组)，即进程表
   - 每个进程占有⼀个进程表项
   - 该表项包含了⼀个进程状态的重要信息
3. 并行与并发
   1. 并发：单个核⼼在很短时间内分别执⾏多个进程
   2. 并行：多个核⼼同时执⾏多个进程称为并⾏
   3. 对于并发来说，CPU需要从⼀个进程切换到另⼀个进程，这个过程需要保存进程的状态信息
4. 进程状态
   - 运行态——占用CPU
   - 就绪态——其他进程运行而暂停，但可运行
   - 阻塞态——等待某一事件而暂定
5. 进程切换为何比线程慢
    1. 每个进程都有自己的虚拟地址空间，但线程共享所在进程的虚拟地址空间。因此在转换时，线程不涉及虚拟内存。
    2. 转换进程需要把虚拟地址转换为物理地址，这需要查找页表。页表查找很慢
    3. Cache缓存？？？ //TODO

### 进程通信
- System V 三种高级进程间通信机制(IPC)
   - 消息队列
   - 共享内存（最快的IPC形式）
   - 信号量
1. 无名管道
   - pipe()函数
     - fd[0]: 读管道
     - fd[1]: 写管道
     - 一般文件I/O函数除了lseek()外都可操作管道
   - 特点
     1. 无名字。只能在具有公共祖先的进程之间使用（父子or兄弟） 
     2. 半双⼯，同⼀时刻只能⼀个⽅向
     3. 只能从⼀端写⼊，另⼀端读出
     4. 先入先出
     5. 管道不是文件，只存在于内从中，不属于文件系统
     6. 在内存中对应一个缓冲区，不同系统大小不同
     7. 一次性。数据一旦被读就会被抛弃
     8. 存在阻塞方式
   - 读写管道的四种情况
     - 写端未关闭时读取
       - 若有数据则读出返回读到字节数，若无数据则阻塞
     - 写段关闭时读取
       - 返回0
     - 读端未关闭时写入
       - 正常写入返回写入字节数；若写满则堵塞
     - 读端关闭时写入
       - 写的进程收到一个信号然后退出
   - 其他
     - 通过`long fpathconf(int fd, int name)`查看管道缓冲区
     - 通过`fcntl()`可设为非阻塞
3. 有名管道(FIFO)
   - 特点
     1. 在文件系统中作为一个特殊的文件而存在，但内容放在内存里
     2. 提供了一个路径名与之关联，只要进程能访问该路径就能通过FIFO通信（不相关的进程也能）
     3. 当使用FIFO的进程退出后，FIFO文件将继续保存在文件系统中
   - 创建
     - 通过命令mkfifo fifo
     - 通过函数`int mkfifo(const char* pathname, mode_t mode)`
   - 读写
     - 读
       - 若有数据则返回读到的字节数
       - 若无数据，写端关闭返回0，未关闭则阻塞
     - 写
       - 读端关闭，进程异常终止orSIGPIPE信号
       - 读端未关闭，管道满则阻塞，未满则返回写入字节数
4. 共享内存
    - 最快的IPC形式
    - 储存映射(Memory map)
      - 通过mmap()函数创建、munmap()函数释放
      - 使一个磁盘文件与储存空间中的一个缓冲区相映射
      - 从缓冲区读/写就会自动读/写文件
      - 不使用read/write函数完成IO操作
    - 匿名映射实现父子通信
      - 内存映射需要依赖文件（必须有实际大小），而且之后还要unlink close掉比较麻烦
      - Linux可使用flags MAP_ANONYMOUS(or MAP_ANON)创建匿名映射区，无需依赖文件
5.  消息队列
    - 特点
      - 保存在内核中的消息链表，每个消息体都是固定大小的存储块
      - 若有进程从消息队列中读取消息，内核就会删掉该消息体
      - 若没有释放消息队列or关闭操作系统，消息队列会一直存在
    - 缺点
      - 通信不及时
      - 每个消息体有大小限制、消息队列长度有限制
      - 存在用户态与内核态之间的数据拷贝开销
6.  信号量
    - 简单、不能携带大量信息、满足某个特定条件才发送
    - 一个完整的信号周期
      - 产生
      - 在进程中的注册/注销
      - 执行信号处理函数、
    - 信号编号
      - 没有0信号，也没有32 33
      - 1-31被称为常规信号，34-64实时信号
      - 比较重要的信号
        - SIGINT <Ctrl+C>
        - SIGQUIT <Ctrl+> 终止信号
        - SIGSEGV 无效内存访问（段错误），终止进程并产生core文件
        - SIGPIPE 向一个没有读端的管道写数据，终止进程
        - SIGCHLD 子进程结束发给父进程
      - 信号四要素
        - 编号
        - 名称
        - 事件
        - 默认处理动作
          - Term 终止进程
          - Ign 忽略信号
          - Core 终止进程生成Core文件，用于gdb调试
          - Stop 停止（暂停）进程
          - Cont 继续运行进程
      - (9)SIGKILL和(19)SIGSTOP信号不允许忽略和捕捉，只能执行默认动作
    - 信号状态
        - 产生
        - 未决（未处理）
        - 递达（被处理了）
    - 信号产生函数
        1. int kill(pid_t pid, int sig)
           - pid > 0 给pid传信号
           - pid = 0 当前进程所在进程组所有进程
           - pid = -1 系统所有进程
           - pid < -1 指定进程组所有进程，pid绝对值
        2. int raise(int sig)
           - 给自己发sig 
        3. void abort(void)
           - 给自己发异常终止信号(6)SIGABRT
        4. unsigned int alarm(unsigned int seconds)
           - 指定时间后给自己发(14)SIGALRM 
        5. int setitimer(...)定时器
    - 自定义信号函数
    - 信号捕捉
      - signal()
      - sigaction()
    - 信号处理函数
7.  套接字

### 僵尸进程
- 避免僵尸进程方法
  1. 最简单的方法，通过wait()/waitpid()等函数等待子进程结束，但会导致父进程挂起
  2. 通过信号处理函数处理信号SIGCHLD
  3. 若父进程不关心子进程什么时候结束，可用signal(SIGCHLD, SIGIGN)通知内核
   
### 守护进程
- 模型
  1. 创建子进程，父进程退出（必须）
     - fork()产生子进程，父进程退出 
  2. 子进程中创建新会话（必须）
     - 通过setsid()使子进程成为会话组长，与原来会话、进程组和终端脱离 
  3. 禁止进程重新打开终端
     - 再次fork()和关闭此进程
  4. 改变当前目录为根目录
     - chdir()函数
  5. 重设文件权限掩码
     - unmask()函数 
  6. 关闭文件描述符
     - 关闭继承过来的非必须文件 
  7. 开始执行守护线程核心工作（必须）
  8. 守护线程退出处理程序

### 进程调度算法
- 批处理系统
  1. 先来先服务
  2. 最短作业优先
  3. 最短剩余时间优先
- 交互式系统
  1. 时间片轮转调度   
  2. 优先级调度
  3. 多级队列
  4. 最短进程优先

## 线程